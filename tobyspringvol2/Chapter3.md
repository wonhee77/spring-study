# 3장 스프링 웹 기술과 스프링 MVC
 
## 3.1 스프링의 웹 프레젠테이션 계층 기술
스프링은 의도적으로 서블릿 웹 애플리케이션의 컨텍스트를 두 가지로 분리해놓았다. 웹 기술에서 완전히 독립적인 비즈니스 서비스 계층과 데이터 액세스 계층을 담은  
루트 애플리케이션 컨텍스트와 스프링 웹 기술을 기반으로 동작하는 웹 관련 빈을 담은 서블릿 애플리케이션 컨텍스트다. 이렇게 스프링 컨텍스트를 두 가지로 분리해둔 이유는  
스프링 웹 서블릿 컨텍스트를 통째로 다른 기술로 대체할 수 있도록 하기 위해서이다.

### 3.1.1 스프링에서 사용되는 웹 프레임워크의 종류

`스프링 서블릿/스프링 MVC`  
스프링이 직접 제공하는 서블릿 기반의 MVC 프레임워크다. 프론트 컨트롤러 역할을 하는 DispatcherServlet을 핵심 엔진으로 사용한다.

`스프링 포틀릿`  
스프링이 제공하는 포틀릿 MVC 프레임워크다.

DispatcherServlet과 MVC 아키텍처  
스프링의 웹 기술은 MVC 아키텍처를 근간으로 하고 있다. MCV는 프레젠테이션 계층의 구성요소의 정보를 담은 모델(M), 화면 출력 로직을 담은 뷰(V), 그리고 제어 로직을  
담은 컨트롤러(C)로 분리하고 이 세 가지 요소가 서로 협력해서 하나의 웹 요청을 처리하고 응답을 만들어 내는 구조이다.  
MVC 아키텍처는 보통 프론트 컨트롤러 패턴과 함께 사용된다. 프론트 컨트롤러 패턴은 중앙 집중형 컨트롤러를 프레젠테이션 계층의 제일 앞에 둬서 서버로 들어오는 모든  
요청을 먼저 받아서 처리하게 만든다. 프론트 컨트롤러는 클라이언트가 보낸 요청을 받아서 공통적인 작업을 먼저 수행한 후에 적절한 세부 컨트롤러로 작업을 위임해주고,  
클라이언트에게 보낼 뷰를 선택해서 최종 결과를 생성하는 등의 작업을 수행한다. 프론트 컨트롤러는 컨트롤러와 뷰, 그리고 그 사이에서 주고받는 모델, 세 가지를 이용해서  
작업을 수행하는게 일반적이다.  
스프링이 제공하는 스프링 서블릿/MVC의 핵심이 DispatcherServlet이라는 프론트 컨트롤러다.  
서버가 브라우저나 여타 HTTP 클라이언트로부터 HTTP 요청을 받기 시작해서 다시 HTTP로 결과를 응답해주기까지의 과정을 살펴보자. 

1. DispatcherServlet의 HTTP 요청 접수  
자바 서버의 서블릿 컨테이너는 HTTP 프로토콜을 통해 들어오는 요청이 스프링의 DispatcherServlet에 할당된 것이라면 HTTP 요청정보를 DispatcherServlet에  
   전달해준다. web.xml에는 DispatcherServlet이 전달 받을 URL의 패턴이 정의되어 있다.  
   ```xml
   <servlet-mapping>
      <servlet-name>Spring MVC Dispatcher Servlet</servlet-name>
      <url-pattern>/app/*</url-pattern>
   </servlet-mapping>
   ```
   
2. DispatcherSevlet에서 컨트롤러로 HTTP 요청 위임  
DispatcherServlet은 URL이나 파라미터 정보, HTTP 명령 등을 참고로 해서 어떤 컨트롤러에게 작업을 위임할지 결정한다. 컨트롤러를 선정하는 것은 Dispatcher  
   Servlet의 핸들러 매핑 전략을 이용한다. 스프링에서는 컨트롤러를 핸들러라고도 부른다. 사용자 요청을 기준으로 어떤 핸들러에게 작업을 위임할지를 결정해주는 것을  
   핸들러 매핑 전략이라고 한다.  
   이를 전략이라고 부르는 이유는 DI의 가장 대표적인 용도로 할 수 있는 전략 패턴이 적용되어 있기 때문이다.  
   DispatcherServlet은 오브젝트 어댑터 패턴을 사용해서 특정 컨트롤러를 호출해야 할 때는 해당 컨트롤러 타입을 지원하는 어댑터를 중간에 껴서 호출하는 것이다.  
   하나의 DispatcherServlet이 동시에 여러 가지 타입의 컨트롤러를 사용할 수 있다. DI를 통해 자유롭게 확장이 가능하다.  
   DispatcherServlet이 핸들러 어댑터에 웹 요청을 전달할 때는 모든 웹 요청 정보가 담긴 HttpServletRequest 타입의 오브젝트를 전달해준다. 이를 어댑터가  
   적절히 변환해서 컨트롤러의 메소드가 받을 수 있는 파라미터로 변환해서 전달해주는 것이다.
   
3. 컨트롤러의 모델 생성과 정보 등록  
MVC 패턴의 장점은 정보를 담고 있는 모델과 정보를 어떻게 뿌려줄지를 알고 있는 뷰가 분리된다는 점이다.  
   컨트롤러의 작업은 먼저 사용자 요청을 해석하는 것, 그에 따라 실제 비즈니스 로직을 수행하도록 서비스 계층 오브젝트에게 작업을 위임하는 것, 그리고 결과를 받아서  
   모델을 생성하는 것, 마지막으로 어떤 뷰를 사용할지 결정하는 것의 네 가지로 분류할 수 있다.
   
4. 컨트롤러의 결과 리턴: 모델과 뷰  
컨트롤로가 뷰 오브젝트를 직접 리턴할 수도 있지만, 보통은 논리적인 이름을 리턴해주면 DispatcherServlet의 전략인 뷰 리졸버가 이를 이용해 뷰 오브젝트를 생성해준다.  
   모델과 뷰를 넘기는 것으로 컨트롤러의 책임은 끝이다. 다시 작업은 DispatcherServlet으로 넘어간다.
   
5. DispatcherServlet의 뷰 호출과 6. 모델 참조  
DispatcherServlet이 컨트롤러로 부터 모델과 뷰를 받은 뒤에 진행하는 작업은, 뷰 오브젝트에게 모델을 전달해주고 클라이언트에게 돌려줄 최종 결과물을 생성해달라고  
   요청하는 것이다. 최종 결과물은 HttpServletResponse 오브젝트 안에 담긴다.
   
7. HTTP 응답 돌려주기  
뷰 생성까지의 모든 작업을 마쳤으면 DispatcherServlet은 등록된 후처리기가 있는지 확인하고, 있다면 후처리기에서 후속 작업을 진행한 뒤에 뷰가 만드어준  
   HttpSevletResponse에 담긴 최종 결과를 서블릿 컨테이너에게 돌려준다.
   
   
#### DispatcherServlet의 DI 가능한 전략 
다양한 방식으로 DispatcherServlet의 동작방식과 기능을 확장, 변경할 수 있도록 준비된 전략들이 존재한다.
`HandlerMapping`  
핸들러 매핑은 URL과 요청 정보를 기준으로 어떤 핸들러 오브젝트, 즉 컨트롤러를 사용할 것인지를 결정하는 로직을 담당한다. DispatcherServlet은 하나 이상의  
핸들러 매핑을 가질 수 있다.  
`HandlerAdapter`  
핸들러 어댑터는 핸들러 매핑으로 선택한 컨트롤러/핸들러를 DispatcherServlet이 호출할 때 사용하는 어댑터다.  
@RequestMapping과 @Controller 애노테이션을 통해 정의되는 컨트롤러의 경우는 DefaultAnnotationHandlerMapping에 의해 핸들러가 결정되고, 그에  
대응되는 AnnotationMethodHandlerAdapter에 의해 호출이 일어난다.
`HandlerExceptionResolver`  
예외가 발생했을 때 이를 처리하는 로직을 갖고 있다.  
`ViewResolver`  
뷰 리졸버는 컨트롤러가 리턴한 뷰 이름을 찾고해서 적절한 뷰 오브젝트를 찾아주는 로직을 가진 전략 오브젝트다.


## 3.2 스프링 웹 애플리케이션 환경 구성
웹어플리케이션 컨텍스트를 구성하는 방법은 크게 세 가지가 있다. 그중 가장 보편적으로 사용되는 루트 컨텍스트와 서블릭 컨텍스트 두 개의 웹 애플리케이션 컨텍스트를  
사용하는 방법을 적용해보자. 서블릿 컨텍스트가 루트 컨텍스트를 부모 컨텍스트로 가지고, 자식 컨텍스트는 부모 컨텍스트를 참조할 수 있지만 그 반대는 안된다.  

