# 4장 스프링 @MVC
스프링은 DispatcherServlet과 7가지 전략을 기반으로 한 MVC 프레임워크를 제공한다. 스프링 MVC 프레임워크의 장점은 유연한 확장이 가능하도록 설계된 MVC 엔진인  
DispatcherServlet이다. 스프링 3.0부터 한층 더 강화된 어노테이션 전략을 활용해서 가장 혁신적인 발전이 생겼다.  
애노테이션을 중심으로 한 새로운 MVC의 확장 기능은 @MVC라는 별칭으로도 불린다. @MVC는 스프링 3.0에서 기존에 가장 많이 사용되던 Controller 타입의 기반  
클래스들을 대부분 대체하게 되었다. 

## 4.1 @RequestMapping 핸들러 매핑
@MVC의 가장 큰 특징은 핸들러 매핑과 핸들러 어댑터의 대상이 오브젝트가 아니라 메소드라는 점이다. @MVC에서는 모든 것이 메소드 레벨로 세분화됐다. 애노테이션은  
부여되는 대상의 타입이나 코드에는 영향을 주지 않는 메타정보이므로 훨씬 유연한 방식으로 컨트롤러를 구성할 수 있게 해준다.  
@MVC의 핸들러 매핑을 위해서는 DefaultAnnotationHandlerMapping이 필요하다. 디폴트 핸들러 매핑 전략이므로 다른 핸들러 매핑 빈을 명시적으로 등록하지  
않았다면 기본적으로 사용할 수 있다. 

### 4.1.1 클래스/메소드 결합 매핑정보
DefaultAnnotationHandlerMapping의 핵심은 매핑정보로 @RequestMapping 애노테이션을 활용한다는 점이다. 스프링은 클래스 레벨과 메소드 레벨에 붙은  
@RequestMapping의 정보를 결합해서 최종 매핑정보를 생성한다. 기본적인 결합 방법은 타입 레벨의 @RequestMapping 정보를 기준으로 삼고, 메소드 레벨의  
@RequestMapping정보는 타입 레벨의 매핑을 더 세분화하는 데 사용하는 것이다. 

#### @RequestMapping 애노테이션
- String[] value(): URL 패턴  
URL 패턴을 지정한다. "/user/{userId}" 처럼 {}을 사용하는 URI 템플릿을 사용할 수도 있다. {}에 들어가는 이름은 패스 변수라고 불리며, 하나 이상 등록할 수  
  있다. URL 패턴은 배열이기 때문에 하나 이상의 URL을 등록할 수 있다. URL 패턴에서 기억해야할 중요한 사실은 디폴트 접미어 패턴이 적용된다는 점이다.   
  @RequestMapping("/hello") 처럼 확장자가 붙지 않고 /로 끝나지도 않는 URL 패턴에는 디폴트 접미어 패턴이 적용되어서 다음 세개의 URL 패턴을 적용했을 때와  
  동일한 결과가 나온다. @RequestMapping({"/hello", "/hello/", "/hello.*"})
  

- RequestMethod[] method(): HTTP 요청 메소드  
GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE 7개의 HTTP 메소드가 정의되어 있다. 같은 URL이라고 하더라도 메소드에 따라 구분할 수 있다.  
  때로는 타입 레벨에는 URL만 주고 메소드 레벨에는 HTTP 요청 메소드만 지정하는 방법을 사용하기도 한다. 이럴때는 URL을 생략할 수도 있다.
  

- String[] params(): 요청 파라미터  
세 번째 매핑 방식은 요청 파라미터와 그 값을 비교해서 매핑해주는 것이다. 같은 URL을 사용하더라도 HTTP 요청 파라미터에 따라 별도의 작업을 해주고 싶을 때가 있다.  
  이때는 코드에서 파라미터를 검사해서 기능을 분리하는 대신 @ReqeustMapping에 매핑을 위한 요청 파라미터를 지정해줄 수 있다. 파라미터는 '타입=값' 형식으로  
  지정해주면 된다. 같은 URL이더라도 파라미터에 따라 다르게 매핑이 된다. 조건을 만족하는 매핑이 여러개 있는 경우는 자세하게 매핑되어 있는 쪽을 우선 시 한다.  
  특정 파라미터가 존재하지 않아야 매핑이 되게 하고 싶으면 params="!type" 처럼 !를 앞에 붙여주면 된다.
  
- String[] headers(): HTTP 헤더  
params와 비슷하게 '헤더이름 = 값'의 형식으로 사용한다.
  
#### 타입 레벨 매핑과 메소드 레벨 매핑의 결합
타입 레벨에 붙는 @RequestMapping은 타입 내의 모든 매핑용 메소드의 공통 조건을 지정할 때 사용한다. 그리고 메소드 레벨에서 조건을 세분화해주면 된다.  
터압 래밸의 URL 패턴에 *나 **을 사용했을 때도 URL을 결합할 수 있다. 타입 레벨에 /user 대신 /user/*를 사용했을 경우 메소드 레벨에 /add가 선언되어 있으면  
/user/add로 결합된다. 타입 레벨에 /user/**로 되어 있다면 메소드 레벨의 /add는 /user/**/add로 결합된다. 

#### 메소드 레벨 단독 매핑
메소드 레벨의 매핑조건에 공통점이 없는 경우라면 타입 레벨에서는 조건을 주지 않고 메소드 레벨에서 독립적으로 매핑정보를 지정할 수 있다. 이때 타입 레벨에는 조건이 없는  
@RequestMapping을 붙여두면 된다. 컨트롤러 클래스에 @Controller 애노테이션을 붙여서 빈 자동스캔 방식으로 등록되게 했다면 클래스 레벨의 @RequestMapping을  
생략할 수도 있다.

#### 타입 레벨 단독 매핑
핸들러 매핑은 원래 핸들러 오브젝트를 결정하는 전략이다. 클래스 레벨의 URL 패턴이 /*로 끝나는 경우에는 메소드 레벨의 URL 패턴으로 메소드 이름이 사용되게 할 수 있다.

