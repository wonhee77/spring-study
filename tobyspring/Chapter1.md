#1장 오브젝트와 의존 관계

스프링의 핵심가치는 자바의 객체 지향적인 관점을 살리는 것이다.  
그래서 오브젝트가 어떻게 생성되고 어떻게 관리되며 어떻게 다른 오브젝트와 관계를 맺는지 등에 대한 관심이 필요하다.  
디자인 패턴, 리팩토링, 테스트 코드 등의 기술과 지식이 필요하다.

## 1.1 초난감 DAO
### 요약
1.1장에서는 DAO를 통해 DB에 User데이터를 저장하고 가져오는 로직을 만들었다.  
DAO 내에 DB에 데이터를 add()하고 get()하는 메서드가 존재한다.  
그리고 static main method를 통해 System.out.println()으로 해당 로직을 테스트하고 있다.

### 용어
`DAO`(Data Access Object) : DB를 통해 데이터를 가져오거나 수정하는 역할을 하는 object

`자바 빈` : 자바 빈은 특정 규약에 따라 작성된 Java 객체이다. 자바 빈은 재사용 가능한 컴포넌트를 만들기 위한 자바 표준이다.  
데이터 저장, 데이터 전송, 여러 레이어 간의 정보 전달 용도로 사용되며 아래의 규칙을 지켜야한다.
1. 필드들을 property라고 부르고 private로 선언이 되어야한다. getter, setter를 이용해 접근을 해야한다.
2. public 접근 제어자의 기본 생성자를 가지고 있어야 한다.
3. Serializable 인터페이스를 구현해야 한다.

## 1.2 DAO의 분리
### 요약
객체 지향의 세계에서는 모든 것이 변한다. 소프트웨어에서 변화가 없으면 죽은 소프트웨어인 것이다.  
그렇기 때문에 항상 변화를 염두해두고 개발을 해야된다.  
변화에 대비하기 위해서는 변화하는 부분을 작게 남겨둬야한다.  
관심사가 같은 것 끼리는 모으고, 관심사가 다른 것은 떨어뜨리는 `관심사의 분리`가 필요하다.

 1.1장의 DAO의 add(), get() 메서드는 DB connection을 가져오는 부분을 공통으로 가지고 있다.  
따라서 관심사를 분리하기 위해 DB connection을 맺는 부분을 getConnection()이라는 메서드로 따로 분리한다.  
이렇게 되면 DB 종류가 바뀐다던지 로그인 정보가 바뀌더라도 한 곳에서만 수정을 하면 된다.  

기능을 추가하지는 않았지만 코드가 더 깔끔해졌고 변화에 더 잘 대응할 수 있는 코드가 되었다. 이를 `리팩토링`이라고 한다.  
 
메소드 추출을 통해 관심사를 분리했지만 해당 DAO의 코드를 바꾸지 않고서는 DB connection 방법을 바꿀 수 없다.  
N 고객사와 D 고객사에 DAO를 제공할 때 각각 다른 DB connection을 사용한다면 코드를 주지 않고서는 connection을 변경할 방법이 없다.  

이러한 상황은 상속을 통해 해결할 수 있다.  
getConnection() 메서드를 추상 메서드로 변경하면 DAO를 상속한 NDAO, DDAO를 생성하여 getConnection() 함수를 오버라이딩 할 수 있다.  
이 방법은 디자인 패턴 중 `템플릿 메소드 패턴`, `팩토리 메서드 패턴`를 사용한 것과 같다.



### 용어  
`디자인 패턴` : 소프트웨어 설계 시 자주 만나는 문제들을 해결하기 위해 사용하는 재사용 가능한 솔루션이다. 각 패턴에 대한 의도 파악이 중요하다.  

`템플릿 메소드 패턴`은 전체 흐름이 있는 가운데 특정 부분만 재정의한 함수를 통해 새로운 행동을 하게하는 패턴이다.  
위와 같은 경우는 DB 연결을 맺고, query를 작성하고, 결과를 전송하고, 결과를 받고 등의 여러 과정 중에 DB 연결을 맺는 부분을 재정의하였다.  
이 방법을 통해 중복코드를 줄일 수 있고 특정 부분만 재정의하여 변경에는 닫혀있고 변화에는 열려있는 open-close를 지킬 수 있다.

`팩토리 메서드 패턴`은 객체를 직접 생성하지 않고 팩토리에게 생성을 위임하여 생성하는 부분을 분리하는 패턴이다.  
위의 예제에서는 DAO의 서브 클래스인 NDAO, DDAO가 팩토리 역할을 하여 각각 다른 DB connection을 생성하고 있다.  
이 방법을 통해 객체 생성은 팩토리에게만 의존하기 때문에 클라이언트 입장에서는 구체화된 객체에 의존할 필요가 없다.  

## 1.3 DAO의 확장
### 요약
이번 장에서는 상속이 아닌 connection 맺는 부분을 클래스로 분리하여 문제를 해결하고자 한다.  
SimpleConnectionMaker는 클래스를 만들고 makeNewConnection()이라는 함수를 구현한다.  
UserDao가 이 SimpleConnection을 필드로 가지고 이 객체를 통해서 connection을 가져온다.  

클래스의 분리를 통해 역할을 분리했지만 생성자에서 SimpleConnection 구현체를 생성하고 필드에 넣어주기 때문에  
UserDao가 특정 ConnectionMaker에 종속적이다. 이러한 경우 인터페이스를 통해 해결할 수 있다.  
ConnectionMaker를 Interface로 만들고 이를 N사와 D사에서 각각 구현한 ConnectionMaker를 사용하면 변화에 유연하게 대처할 수 있다.  

하지만 여기서도 UserDao는 특정 ConnectionMaker에 의존을 하게 된다.  
이 문제는 UserDao 외부 즉, 클라이언트에서 어떤 ConnectionMaker를 사용할건지를 결정할 수 있도록 넘기면 해결 된다.  
예제에서는 main() 메소드에서 UserDao를 호출하고 있는데 자바는 다형성을 지원하기 때문에 UserDao 객체를 생성할 때 클라이언트에서  
ConnectionMaker의 구현체를 생성자로 넣어주면 UserDao는 ConnectionMaker라는 추상에만 의존하고 실제 구현은 외부에서 결정하게 된다.  

UserDao와 ConnectionMaker는 관계를 맺지 않을 수는 없다. 하지만 클래스 사이에서 관계가 맺어 지는 것이 아니라 단지 오브젝트 사이에 다이내믹한  
관계가 만들어지는 것이다. 이 다이내믹한 관계를 맺어주는건 UserDao를 사용하는 client이다. 여기서는 코드를 실행하는 main() 메서드가 client가 된다.  



### 용어
`개방 폐쇄의 원칙` : 개방 폐쇄의 원칙을 통해 지금까지 해온 리팩토링 작업을 효과적으로 설명할 수 있다.  
개방 페쇄의 원칙은 `클래스나 모듈의 확장에는 열려 있어야하고 변경에는 닫혀있어야 한다`이다.  
위의 에제에서는 DB 연결 방법을 확장하는데는 열려있으나 UserDao를 변경하지 않아도 되므로 변경에는 닫혀있다.

`객체 지향의 원칙 SOLID`  
`SRP`(The Single Responsibility Principle) : 단일 책임 원칙  
`OCP`(The Open Closed Principle) : 개방 폐쇄 원칙  
`LSP`(The Liskov Substitution Principle) : 리스코프 치환 원칙  
`ISP`(The Interface Segregation Principle) : 인터페이스 분리 원칙  
`DIP`(The Dependency Inversion Principle) : 의존 관계 역전 원칙  

`응집도` : 응집도가 높다는 것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 것이다.  
변화가 생기면 해당 모듈에서의 변화가 크고 다른 곳에서의 변화가 작다. 그렇기 때문에 변화가 일어나도 어디를 수정해야되는지 파악하기 쉽고  
다른 곳에 영향을 끼칠 확률도 적어진다.  
`결합도` : 결합도는 책임과 관심사가 다른 오브젝트 또는 모듈과 느슨한 관계를 유지하는 것을 말한다.  
변화가 필요할 때 하나를 수정함으로 인해 여러 곳이 변경되면 결합도가 높다. 이러한 상황을 지양해야 한다.  

`전략 패턴` : 전략 패턴은 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고,  
이를 구현한 구체적인 알고리즘을 필요에 따라 바꿔서 사용할 수 있게 하는 패턴이다.  
이 패턴을 통해 개방 폐쇄의 원칙을 지킬 수 있었다.

