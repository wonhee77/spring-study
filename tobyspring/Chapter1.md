# 1장 오브젝트와 의존 관계

스프링의 핵심가치는 자바의 객체 지향적인 관점을 살리는 것이다.  
그래서 오브젝트가 어떻게 생성되고 어떻게 관리되며 어떻게 다른 오브젝트와 관계를 맺는지 등에 대한 관심이 필요하다.  
디자인 패턴, 리팩토링, 테스트 코드 등의 기술과 지식이 필요하다.

## 1.1 초난감 DAO

### 요약
1.1장에서는 DAO를 통해 DB에 User데이터를 저장하고 가져오는 로직을 만들었다.  
DAO 내에 DB에 데이터를 add()하고 get()하는 메서드가 존재한다.  
그리고 static main method를 통해 System.out.println()으로 해당 로직을 테스트하고 있다.

### 용어
`DAO`(Data Access Object) : DB를 통해 데이터를 가져오거나 수정하는 역할을 하는 object

`자바 빈` : 자바 빈은 특정 규약에 따라 작성된 Java 객체이다. 자바 빈은 재사용 가능한 컴포넌트를 만들기 위한 자바 표준이다.  
데이터 저장, 데이터 전송, 여러 레이어 간의 정보 전달 용도로 사용되며 아래의 규칙을 지켜야한다.
1. 필드들을 property라고 부르고 private로 선언이 되어야한다. getter, setter를 이용해 접근을 해야한다.
2. public 접근 제어자의 기본 생성자를 가지고 있어야 한다.
3. Serializable 인터페이스를 구현해야 한다.


## 1.2 DAO의 분리

### 요약
객체 지향의 세계에서는 모든 것이 변한다. 소프트웨어에서 변화가 없으면 죽은 소프트웨어인 것이다.  
그렇기 때문에 항상 변화를 염두해두고 개발을 해야된다.  
변화에 대비하기 위해서는 변화하는 부분을 작게 남겨둬야한다.  
관심사가 같은 것 끼리는 모으고, 관심사가 다른 것은 떨어뜨리는 `관심사의 분리`가 필요하다.

 1.1장의 DAO의 add(), get() 메서드는 DB connection을 가져오는 부분을 공통으로 가지고 있다.  
따라서 관심사를 분리하기 위해 DB connection을 맺는 부분을 getConnection()이라는 메서드로 따로 분리한다.  
이렇게 되면 DB 종류가 바뀐다던지 로그인 정보가 바뀌더라도 한 곳에서만 수정을 하면 된다.  

기능을 추가하지는 않았지만 코드가 더 깔끔해졌고 변화에 더 잘 대응할 수 있는 코드가 되었다. 이를 `리팩토링`이라고 한다.  
 
메소드 추출을 통해 관심사를 분리했지만 해당 DAO의 코드를 바꾸지 않고서는 DB connection 방법을 바꿀 수 없다.  
N 고객사와 D 고객사에 DAO를 제공할 때 각각 다른 DB connection을 사용한다면 코드를 주지 않고서는 connection을 변경할 방법이 없다.  

이러한 상황은 상속을 통해 해결할 수 있다.  
getConnection() 메서드를 추상 메서드로 변경하면 DAO를 상속한 NDAO, DDAO를 생성하여 getConnection() 함수를 오버라이딩 할 수 있다.  
이 방법은 디자인 패턴 중 `템플릿 메소드 패턴`, `팩토리 메서드 패턴`를 사용한 것과 같다.

### 용어  
`디자인 패턴` : 소프트웨어 설계 시 자주 만나는 문제들을 해결하기 위해 사용하는 재사용 가능한 솔루션이다. 각 패턴에 대한 의도 파악이 중요하다.  

`템플릿 메소드 패턴`은 전체 흐름이 있는 가운데 특정 부분만 재정의한 함수를 통해 새로운 행동을 하게하는 패턴이다.  
위와 같은 경우는 DB 연결을 맺고, query를 작성하고, 결과를 전송하고, 결과를 받고 등의 여러 과정 중에 DB 연결을 맺는 부분을 재정의하였다.  
이 방법을 통해 중복코드를 줄일 수 있고 특정 부분만 재정의하여 변경에는 닫혀있고 변화에는 열려있는 open-close를 지킬 수 있다.

`팩토리 메서드 패턴`은 객체를 직접 생성하지 않고 팩토리에게 생성을 위임하여 생성하는 부분을 분리하는 패턴이다.  
위의 예제에서는 DAO의 서브 클래스인 NDAO, DDAO가 팩토리 역할을 하여 각각 다른 DB connection을 생성하고 있다.  
이 방법을 통해 객체 생성은 팩토리에게만 의존하기 때문에 클라이언트 입장에서는 구체화된 객체에 의존할 필요가 없다.


## 1.3 DAO의 확장

### 요약
이번 장에서는 상속이 아닌 connection 맺는 부분을 클래스로 분리하여 문제를 해결하고자 한다.  
SimpleConnectionMaker는 클래스를 만들고 makeNewConnection()이라는 함수를 구현한다.  
UserDao가 이 SimpleConnection을 필드로 가지고 이 객체를 통해서 connection을 가져온다.  

클래스의 분리를 통해 역할을 분리했지만 생성자에서 SimpleConnection 구현체를 생성하고 필드에 넣어주기 때문에  
UserDao가 특정 ConnectionMaker에 종속적이다. 이러한 경우 인터페이스를 통해 해결할 수 있다.  
ConnectionMaker를 Interface로 만들고 이를 N사와 D사에서 각각 구현한 ConnectionMaker를 사용하면 변화에 유연하게 대처할 수 있다.  

하지만 여기서도 UserDao는 특정 ConnectionMaker에 의존을 하게 된다.  
이 문제는 UserDao 외부 즉, 클라이언트에서 어떤 ConnectionMaker를 사용할건지를 결정할 수 있도록 넘기면 해결 된다.  
예제에서는 main() 메소드에서 UserDao를 호출하고 있는데 자바는 다형성을 지원하기 때문에 UserDao 객체를 생성할 때 클라이언트에서  
ConnectionMaker의 구현체를 생성자로 넣어주면 UserDao는 ConnectionMaker라는 추상에만 의존하고 실제 구현은 외부에서 결정하게 된다.  

UserDao와 ConnectionMaker는 관계를 맺지 않을 수는 없다. 하지만 클래스 사이에서 관계가 맺어 지는 것이 아니라 단지 오브젝트 사이에 다이내믹한  
관계가 만들어지는 것이다. 이 다이내믹한 관계를 맺어주는건 UserDao를 사용하는 client이다. 여기서는 코드를 실행하는 main() 메서드가 client가 된다.

### 용어
`개방 폐쇄의 원칙` : 개방 폐쇄의 원칙을 통해 지금까지 해온 리팩토링 작업을 효과적으로 설명할 수 있다.  
개방 페쇄의 원칙은 `클래스나 모듈의 확장에는 열려 있어야하고 변경에는 닫혀있어야 한다`이다.  
위의 에제에서는 DB 연결 방법을 확장하는데는 열려있으나 UserDao를 변경하지 않아도 되므로 변경에는 닫혀있다.

`객체 지향의 원칙 SOLID`  
`SRP`(The Single Responsibility Principle) : 단일 책임 원칙  
`OCP`(The Open Closed Principle) : 개방 폐쇄 원칙  
`LSP`(The Liskov Substitution Principle) : 리스코프 치환 원칙  
`ISP`(The Interface Segregation Principle) : 인터페이스 분리 원칙  
`DIP`(The Dependency Inversion Principle) : 의존 관계 역전 원칙  

`응집도` : 응집도가 높다는 것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 것이다.  
변화가 생기면 해당 모듈에서의 변화가 크고 다른 곳에서의 변화가 작다. 그렇기 때문에 변화가 일어나도 어디를 수정해야되는지 파악하기 쉽고  
다른 곳에 영향을 끼칠 확률도 적어진다.  
`결합도` : 결합도는 책임과 관심사가 다른 오브젝트 또는 모듈과 느슨한 관계를 유지하는 것을 말한다.  
변화가 필요할 때 하나를 수정함으로 인해 여러 곳이 변경되면 결합도가 높다. 이러한 상황을 지양해야 한다.  

`전략 패턴` : 전략 패턴은 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고,  
이를 구현한 구체적인 알고리즘을 필요에 따라 바꿔서 사용할 수 있게 하는 패턴이다.  
이 패턴을 통해 개방 폐쇄의 원칙을 지킬 수 있었다.


## 1.4 제어의 역전(IOC)

### 요약
이전 장의 코드에서는 UserDao가 어떤 ConnectionMaker를 사용할지는 UserDaoTest 라는 클래스가 담당했다.  
UserDaoTest 클래스는 테스트를 위한 역할로만 사용되어야 하기 때문에 UserDao가 ConnectionMaker를 사이의 관계를 DaoFactory를 구현하여  
해결한다. DaoFactory의 userDao()라는 메소드를 통해 UserDao 객체를 생성하고 ConnectionMaker 객체를 생성하여 생성자로 연결한다.  
이 방식을 통해 UserDaoTest 클래스에서는 어떤 ConnectionMaker를 사용할지 객체를 어떻게 생성할지 결정하지 않고,  
Factory에 요청해서 가져올 수 있다. 즉 각각이 역할을 가지고 자신의 역할에만 충실해질 수 있다.  

만약 DaoFactory에서 UserDao뿐만 아니라 AccountDao 등 다양한 Dao를 생성하는 메소드가 추가된다면 각각은 또 ConnectionMaker가 필요하다.  
ConnectionMaker는 읽기만 하니 하나를 만들어서 동시에 모두가 사용할 수 있다. 그래서 함수로 분리를 하여 connection에 대한 것을 한 곳에서  
수정할 수 있도록 한다.  

### 용어
`IOC(제어의 역전)` : 보통의 프로그램은 main() 메서드에서 시작하여 시작되는 지점부터 다음 사용할 오브젝트들을 결정하고, 생성하고, 호출하고,  
만들어진 오브젝트에 있는 메서드를 호출하고, 그 메소드 안에서 다시 같은 과정을 반복하게 된다.  
제어의 역전이란 이런 흐름을 거꾸로 뒤집는 것이다.  

제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 모든 제어 권한을 다른 대상에게 위임하기 때문이다.  
템플릿 메소드 패턴에서 추상 메서드를 구현했지만 어떻게 사용될지는 알지 못하고 슈퍼클래스에 의해 호출이 된다.  
또한 프레임워크도 제어의 역전의 일종이라고 할 수 이따. 라이브러리는 프로그램 흐름에서 필요한 오브젝트를 능동적으로 호출하지만 프레임워크는  
작성한 코드가 프레임워크에 의해 불려서 사용될 뿐이다.  

IOC 모델을 통해 설계가 깔끔해지고, 유연성과 확장성이 증가시킬 수 있다.  


## 1.5 스프링의 IOC

###요약
앞서 만든 DaoFactory를 스프링이 직접 관리하는 하도록 만들 수 있다.  
스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈이라고 부른다.  
그리고 빈의 생성과 관계 설정을 관리하는 IOC 오브젝트를 빈 팩토리라고 부른다. 보통은 빈팩토리보다 이를 조금 더 확장한 어플리케이션 컨텍스트를 사용한다.  
빈팩토리는 빈을 생성하고 관계를 형성하는 IOC의 기본적인 기능에 초점을 맞춘 것이고, 어플리케이션 컨텍스트는 IOC 엔진 의미가 더 부각된다.  

DaoFactory 클래스에 @Configuration 어노테이션을 붙이고, UserDao를 생성하는 메소드와 ConnectionMaker를 생성하는 메소드에  
@Bean 어노테이션을 붙여주면 DaoFactory가 스프링에서 IOC 기능을 사용할 설정 정보가 된다.  

@Configuration이 붙은 자바 코드를 설정정보로 사용하려면 ApplicationContext를 구현한 AnnotationConfigApplicationContext를 사용하면 된다.  
ApplicationContext의 getBean()이라는 메소드를 통해 등록한 빈을 가져올 수 있다.  
```java
    ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
    UserDao dao = context.getBean("userDao", UserDao.class);
```
Config 파일에서 @Bean 어노테이션을 붙여준 함수가 bean의 이름이 된다.  
bean을 가져올 때 이름으로만 가져오면 Object type으로 반환하기 때문에 두번째 인자로 Class에 대한 정보를 넘겨 제네릭으로 원하는 타입의 빈을 바로 가져올 수 있다.  

어플리케이션 컨텍스트를 통해 얻을 수 있는 장점
- 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.  
  DaoFactory는 IOC를 적용한 오브젝트를 가져오기 위해서라면 어떤 팩토리를 사용해야될지를 알아야 하고, 필요할 때 마다 팩토리를 생성해야 된다.  
  하지만 어플리케이션 컨텍스트를 사용하면 일관된 방법으로 오브젝트를 가져올 수 있고, XML을 설정 정보로 사용할 수도 있다.
  
- 어플리케이션 컨텍스트는 종합 IOC 서비스를 제공해준다.  
  어플리케이션 컨텍스트는 단순히 오브젝트 생성, 관계 연결을 해주는 역할 뿐만 아니라 오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 있고,  
  자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.  
  
- 어플리케이션 컨텍스트는 빈을 검색하는 다양항 방법을 제공한다.  
  타입으로 빈을 검색하거나 특별한 어노테이션이 설정되어 있는 빈을 찾을 수도 있다.

###용어
`Bean` : 스프링이 IoC 방식으로 관리하는 오브젝트이다.

`Bean Factory` : 스프링의 IoC를 담당하는 핵심 컨테이너. 빈을 등록, 생성, 조회와 부가적인 빈 관리 기능을 제공한다.  
보통은 기능이 확장된 ApplicationContext 오브젝트를 사용한다.  

`Application Context` : 빈 팩토리를 확장한 IoC 컨테이너이다. 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다.  

`Congfiguration / Metadata` : 어플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보이다.

`Container or IoC Container` : IoC 방식으로 빈을 관리한다는 의미에서 빈 팩토리나 어플리케이션 컨텍스트를 IoC 컨테이너라고 부른다.

`Spring Framework` : IoC 컨테이너, 어플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말한다.  


## 1.6 싱글톤 레지스트리와 오브젝트 스코프

### 요약
기존의 DaoFactory를 사용하여 오브젝트를 가져오면 항상 같은 객체를 반환하지 않는다. 호출할 때 마다 객체를 새로 생성하기 때문이다.  
반면에 어플리케이션 컨텍스트에 등록한 DaoFactory에서 getBean() 메소드를 통해 오브젝트를 가져오면 호출할 때 마다 같은 빈을 반환한다.  
어플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이다.  

스프링은 엔터프라이즈 환경에서 주로 서버 역할을 한다. 요청이 많을 경우 기존의 DaoFactory 방식에서는 요청이 올 때마다 새로운 객체를 생성한다.  
이는 메모리와 같은 리소스의 낭비이다. 따라서 서버 환경에서는 싱글톤을 사용하는 것이 좋다.  

싱글톤을 만드는 방법
생성자를 private로 변경한다.  
내부에 자신과 같은 타입의 static 필드를 정의한다.  
static 팩토리 메소드인 getInstance()를 만들고 synchronized 키워드로 동기화한다.  
getInstance()를 호출할 경우 static 필드가 null이면 새롭게 생성, 이미 존재하면 존재하는 instance를 반환한다. 

싱글톤에는 문제도 존재한다.  
1. private 생성자로 인해 상속이 불가능하다.  
2. 싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트하기 힘들다.  
3. 특정 환경에서는 싱글톤을 보장받지 못한다.  
4. 전역 상태를 갖기 때문에 동기화 문제가 생길 수 있다.  

스프링은 기본적인 싱글톤 생성 방식을 사용하지 않고 스스로 오브젝트를 만들고 관리하는 싱글톤 레지스트리 기능을 제공한다.  
그렇기 때문에 private 생성자를 가질 필요도 없고 테스트 환경에서도 유연성 있게 사용될 수 있다.  
가장 중요한 것은 객체지향, 디자인 패턴 등을 적용하는데 아무 제약이 없는 것이다.  

싱글톤은 여러 오브젝트에서 접근할 수 있기 때문에 상태정보를 가지고 있지 않은 stateless 형식으로 만들어져야 한다.  


## 1.7 의존관계 주입(DI)

### 요약
IoC는 매우 느슨하게 정의되어서 폭넓게 사용되는 용어이다. 그래서 스프링이 제공하는 IoC 방식을 의존관계 주입(Dependency injection)이라는  
좀 더 의도가 명확하게 드러나는 용어를 사용하기 시작했다.  

오브젝트 A가 변할 때 A의 변화에 의해 B에 영향을 끼치면 B는 A를 의존하고 있다고 말할 수 있다.  
UserDao는 ConnectionMaker 인터페이스에만 의존을 하고 있기 때문에 ConnectionMaker 인터페이스가 변경되면 변경이 필요하지만  
ConnectionMaker의 구현체가 바뀌면 UserDao는 변경을 하지 않아도 된다. 이런 느슨한 연결을 통해 결합도를 낮출 수 있다.  
UML에서 드러나는 의존관계는 설계 모델 관점에서의 의존관계이지만 런타임 시에 오브젝트 사이에서 만들어지는 의존관계도 있다.  
런타임 이전에는 설계나 코드상으로는 어떤 관계를 맺는지 알 수 없다. 그러기 위해서는 인터페이스에만 의존을 하고 있어야 한다.  
또한 의존관계는 사용할 오브젝트를 외부에서 주입을 해줘야 한다.  
의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제 3자가 존재하는 것이고, 빈 팩토리, 어플리케이션 컨텍스트,  
IoC 컨테이너 등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지는 제 3의 존재이다.  

의존관계 검색(Dependency Lookup)은 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하는 것이다.  
어플리케이션 컨텍스트의 getBean()이라는 메소드가 의존관계 검색을 사용하는 것이다. IoC의 개념을 잘 따르는 것이긴 하지만 외부에서 의존관계를  
주입받는 것이 아니라 스스로가 필요한 빈을 검색을 한다.

의존관계 검색은 코드 안에 오브젝트 팩토리 클래스나 스프링 API가 나타나기 때문에 해당 오브젝트의 역할에 충실하지 못하다.  
따라서 의존관계 주입을 사용하는 것이 좋으나 의존관계 검색은 검색하는 오브젝트가 스프링 빈일 필요는 없다.  
의존관계 주입을 통해 빈을 주입 받으려면 주입 받는 오브젝트도 스프링 컨테이너에 의해 관리되는 오브젝트여야 한다.  
빈을 주입하기 위해서는 주입 받는 오브젝트에 대한 생성과 초기화 권한이 필요하기 때문이다.  

의존관계 주입의 응용 사례

1. 기능 구현의 교환  
  로컬에서 테스트하기 위해 ConnectionMaker 구현체를 LocalDbConnectionMaker로 교체할 때 의존관계 주입을 사용하지 않으면 모든 Dao에서  
  DB 연결 정보를 다 바꿔줘야 한다. 의존관계 주입을 사용하면 @Configuration 설정 정보 클래스에서 한 줄만 교체하면 DAO 코드에 대한 변경 없이  
   DB 연결 정보를 교체할 수 있다.  
   

2. 부가기능 추가  
  DB 연결 횟수를 카운팅하고 싶으면 모든 DAO의 makeConnection() 호출 메소드에 로직을 추가해야 한다.  
   DI 컨테이너를 사용한다면 DAO와 DB를 연결하는 오브젝트 사이에 연결 횟수를 카운팅하는 오브젝트를 추가함으로써 해결할 수 있다.  
   ConnectionMaker 인터페이스를 구현하는 CountingConnectionMaker를 만들고 내부에 카운팅하는 로직을 추가한다.  
   그리고 CountingConnectionMaker가 DB연결을 해주는 ConnectionMaker를 호출한다. 그러면 CountingConnectionMaker는  
   기존 코드의 변경 없이 DAO와 실제 DB와 연결을 맺는 ConnectionCounter 사이에서 연결 횟수를 카운트하는 기능만 추가해줄 수 있다.  
   DI의 장점은 관심사의 분리를 통해 얻어지는 높은 응집도에서 나온다.
   
지금까지는 생성자를 통해 의존관계 주입을 하였다. 하지만 그 외에도 주입을 할 수 있는 방법이 있다.  
1. 수정자 메소드를 통한 주입  
  set으로 시작하는 메소드를 통해 어트리뷰트를 주입받는다. 주입받은 어트리뷰트를 저장해놓았다가 내부 메소드에서 사용하게 하는 DI 방식에서 좋다.  
   

2. 일반 메소드를 이용한 주입  
  수정자는 하나의 파라미터 밖에 받을 수 없지만 여러개의 파라미터를 한 번에 받을 때에는 일반 메소드를 통한 주입을 사용할 수도 있다.  
   

