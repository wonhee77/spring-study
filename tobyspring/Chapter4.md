# 4장 예외

## 4.1 사라진 SQLException

### 요약
3장에서는 deleteAll() 메소드에서는 SQLException을 throw한다. 하지만 jdbcTemplate으로 바꾼 뒤에는 throw가 사라졌다.  

초난감 예외처리의 대표들을 알아보자.  

#### 예외 블랙홀
catch 에서 예외를 잡고 아무것도 하지 않는 것이다. 예외를 처리할 때 반드시 지켜야 할 핵심 원칙은 한가지이다. 모든 예외는 적절하게 복구되든지 아니면  
작업을 중단시키고 운영자 또는 개발자가에게 분명하게 통보돼야 한다.  

#### 무의미하고 무책임한 throws
chtch 블록으로 예외를 잡아봐야 해결할 방법도 없고 JDK API나 라이브러리가 던지는 각종 이름도 긴 예외들을 처리하는 코드를 매번 throws로 선언하기도 귀찮아지기 시작하면  
메소드 선언에 throws Exception을 기계적으로 무책임하게 던진다.  

자바에서 예외는 크게 3가지가 있다.  
- Error : 에러는 시스템에 뭔가 비정상적인 상황이 발생했을 경우에 사용된다. 주로 자바 VM에서 발생시키는 것이고 어플리케이션 코드에서 잡으려고 하면 안된다.  
- Exception과 체크 예외 : 치크 예외는 Exception 클래스의 서브클래스이면서 RuntimeException 클래스를 상속하지 않은 것들이고, 후자는 RuntimeException을  
상속한 클래스들을 말한다. 체크 예외가 발생할 수 있는 메소드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 한다.
- RuntimeException과 언체크/런타임 예외 : RuntimeException 클래스를 상속한 예외들은 명시적인 예외처리를 강제하지 않기 때문에 언체크 예외라고 불린다.  
런타임 예외는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들이다.
  
예외 처리하는 일반적인 방법

- 예외 복구 : 예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것이다.  
- 예외 처리 회피 : 예외 처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것이다.  
- 예외 전환 : 예외를 복구해서 정상 상태로 만들 수 없기 때문에 예외를 메소드 밖으로 던진다. 하지만 예외 회피와 달리 발생한 예외를 그대로 넘기는 게 아니라 적절한  
예외로 전환해서 던진다는 특징이 있다. 예외 전환은 보통 두 가지 목적으로 사용된다. 첫째는 내부에서 발생한 예외를 그대로 던지는 것이 그 예외 상황에 대해 적절한 의미를  
  부여해주지 못하는 경우 의미를 분명하게 해주는 예외로 변경하는 것이다. 보통 전환하는 예외에 원래 발생한 예외를 담아서 중첩 예외로 만드는 것이 좋다.  
  중첩 예외는 getCause() 메소드를 이용해서 처음 발생한 예외가 무엇인지 확인할 수 있다. 두번째는 예외를 처리하기 쉽고 단순하게 만들기 위해 포장하는 것이다.  
  주로 체크 예외를 언체크 예외로 변환한다.  
  어차피 복구하지 못할 예외라면 어플리케이션 코드에서는 런타임 예외로 포장해서 던져버리고, 예외 처리 서비스 등을 이용해 자세한 로그를 남기고, 메일로 통보를 하는게 좋다.  
  
대응이 불가능한 체크 예외라면 빨리 런타임 예외로 전환해서 던지는게 낫다. 최근 등장하는 표준 스펙에서는 체크 예외 대신에 언체크 예외로 정의하는 것이 일반화되고 있다.  



