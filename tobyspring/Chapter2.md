# 2장 테스트

## 2.1 UserDaoTest 다시보기

### 요약
웹을 이용해서 테스트를 진행한다면 필요한 기능이 다 만들어져야 하고, 에러가 발생하더라도 어디서 에러가 발생했는지 직접 다 찾아야 한다.  
그리고 테스트하기를 원하는 코드 이외에 다른 부분에서 에러가 날 수 있다.

따라서 테스트는 가능한 작은 단위로 할 수 있어야 한다. 이렇게 작은 단위의 코드에 대한 테스트를 단위 테스트라고 한다.  
테스트는 자동으로 수행되어야 한다. 자동으로 수행된다면 테스트하기 위한 번거로운 과정이 없기 때문에 테스트를 자주 실행할 수 있다.

기존의 UserDaoTest는 자동으로 실행할 수 있는 코드이지만 값의 출력을 일일이 확인을 해야되고 main() 메소드가 많아지면  
하나하나 실행해서 확인해야되는 번거로움이 존재한다.

### 용어
`단위 테스트` : 작은 단위의 테스트


## 2.2 UserDaoTest 개선

### 요약
모든 테스트는 두가지 결과를 가질 수 있다. 실행 중 에러가 발생해서 실패하는 경우와 결과가 기대한 값과 다른 경우.  
기존의 UserDaoTest에서는 출력되는 값을 눈으로 확인만 했다. 그래서 출력 결과가 기대한 값과 같을 경우 테스트 성공, 다를 경우  
테스트 실패를 출력하도록 변경하면 콘솔에 테스트 성공이라는 문장만 확인하면 된다.

프로그램이 커질수록 main() 메소드에서만 테스트하기는 힘들다. 그래서 자바 테스팅 프레임워크인 JUnit을 사용할 수 있다.  
main() 메소드는 제어권을 직접 가지기 때문에 테스트 프레임워크에서 사용하기 적합하지 않다.

main() 메소드에 @Test 어노테션을 붙이고 접근 제어자를 public으로 만들면 테스트 프레임워크에서 사용할 수 있다.  
그리고 main() 메소드 대신에 무슨 테스트인지 알아차리기 쉬운 메소드 이름으로 변경하면 된다.

기존에는 테스트 결과를 equal() 메소드로 확인했지만 JUnit에서는 assertThat() 에서 두 파라미터를 매처라고 불리는 조건으로 판단해서  
일치하면 다음으로 넘어가고, 불일치하면 테스트가 실패하도록 만들어 준다.

JUnit이 실행되기 위해서는 어디에서든 main() 클래스에서 JUnitCore.main() 을 실행하면서 @Test가 있는 클래스를 넘겨주면 된다.

### 용어
`JUnit` : 자바 테스팅 프레임워크


## 2.3 개발자를 위한 테스팅 프레임워크 JUnit

### 요약
기존 테스트에서는 DB에 데이터가 있으면 지워주는 일을 반복해서 했어야 했다. 즉 테스트가 외부 상태에 따라 성공할 수도 있고, 실패할 수도 있다는 것이다.  
코드에 변경사항이 없다면 항상 같은 결과를 리턴해야 된다.  
일관성 있는 테스트를 위해 deleteAll(), getCount() 함수를 추가한다.

JUnit은 특정 테스트 메소드의 실행 순서를 보장해주지 않는다.  
JUnit 테스트에서 예외조건 테스트를 위해서는 @Test(expected=Exception.class)처럼 expected를 통해 확인할 수 있다.

개발자는 빨리 테스트를 만들어 성공하는 것을 보고 다음 기능으로 나아가고 싶어하기 때문에 네거티브한 테스트를 먼저 만드는 것이 좋다.  
테스트 코드를 조건, 행위, 결과처럼 잘 만들어 놓으면 테스트 코드 자체가 일종의 기능 정의서가 될 수 있다.

테스트 주도 개발(TDD, Test Driven Development)는 테스트를 코드보다 먼저 작성한다.  
"실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다."를 기본 원칙으로 한다.  
코드를 먼저 작성한다면 빨리 기능을 완성시키고 싶거나, 코드를 완성시키면 테스트코드를 짜기 귀찮게 되는 상황이 생길 수 있다.  
또한 작성된 코드가 많기 때문에 어디부터 테스트를 해야할지 막막할 수도 있다.  
TDD에서는 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업 주기를 최대한 짧게 가져가야 한다.

JUnit 프레임워크에서는 테스트 메소드를 실행할 때 부가적으로 해주는 작업이 몇 가지 있다. 그중에서 테스트를 실행할 때마다 반복되는 준비 작업을 별도의 메소드에 넣게 해주고,  
매번 테스트가 실행되기 전에 먼저 실행하주는 기능이 존재한다.
@Before이라는 어노테이션을 붙인 함수를 작성하면 매 테스트 코드가 실행되기 전에 먼저 실행시켜준다.

JUnit이 테스트를 수행시키는 방식
1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스 오브젝트를 하나 만든다.
3. @Before가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트에 대해 2~5를 반복한다.
7. 모든 테스트 결과를 종합해서 돌려준다.

JUnit은 각 테스트가 서로 영향을 주지 않고 독립적으로 실행되게 하기 위해서 테스트 메소드를 실행할 때마다 매번 새로운 오브젝트를 생성한다.


## 2.4 스프링 테스트 적용

### 요약
JUnit 프레임워크는 테스트 메소드를 실행할 때 마다 매번 새로운 테스트 클래스 오브젝트를 만들고 어플리케이션 컨텍스트를 초기화 한다.  
스프링 빈이 복잡한 경우에는 빈을 생성하고 등록하는데 많은 시간이 소모된다. 그래서 여러 테스트에 메소드가 어플리케이션 컨텍스트를 하나를 공유하는 방법을 지원한다.  

```java
@RunWith(SpringJUnit4ClassRunner.class) // 스프링의 테스트 컨텍스트 프레임워크의 JUnit 확장기능 지정
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDaoTest {
    @Autowired
    private ApplicationContext context;
}
```

@RunWith는 JUnit 프레임워크의 테스트 실행 방법을 확장하는데 사용되는 어노테이션이다. Spring의 JUnit 확장 프로그램이 어플리케이션 컨텍스트를 빈으로 등록하게 도와준다.  
테스트가 실행되기 전에 딱 한 번만 어플리케이션 컨텍스트를 만들어두고 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해서 어플리케이션 컨텍스트를 특정 필드에 주입한다.

스프링 테스트 컨텍스트 프레임워크는 같은 테스트 오브젝트의 테스트들 뿐만 아니라 여러 개의 클래스에 걸쳐서 어플리케이션을 공유할 수도 있다.  
@Autowired가 붙은 인스턴스 변수가 잇으면, 테스트 컨텍스트 프레임워크는 변수타입과 일치하는 컨텍스트 내의 빈을 찾아서 주입해준다.  

ApplicationContext는 빈으로 등록하지 않았음에도 불구하고 @Autowired를 통해 주입 받을 수 있다. 초기화할 때 자신도 빈으로 등록하기 때문이다.  

@Autowired로 빈을 찾을 때는 첫번째는 타입으로 찾고, 같은 타입의 빈이 여러개일 경우 변수 이름으로 빈을 찾는다.  

#### DI와 테스트
구현체를 빈으로 등록할 수도 있지만 인터페이스를 빈으로 등록하는게 더 나은 이유  
1. 소프트웨어 개발에서는 절대 바뀌지 않는 것은 없다. 나중에 변경될 가능성이 있기 때문
2. 새로운 기능을 추가할 수 있다. 앞에서 살펴본 것처럼 인터페이스 사이에 특별한 기능을 추가한 인터페이스를 추가할 수 있다.  
3. 테스트를 쉽게 만들어 준다. DI로 인해 테스트가 작은 단위의 대상에 독립적으로 만들어지고 실행되게 해준다.  
    DI는 스프링에 제한된 것이 아니기 때문에 테스트용 구현체를 만들어 주입해줄 수도 있다.
   
테스트 코드에 의한 DI  
DataSource의 연결 정보를 실제 운영 환경에 맞출 수 없기 때문에 테스트코드에서 직접 local 테스트용 DataSource를 만들어서 주입할 수 있다.  

테스트를 위한 별도의 DI 설정  
테스트에서 직접 구현체를 만들어 등록해줄 수도 있지만 applicationContext.xml 대신 test-applicationContext.xml 처럼 테스트용 설정 파일을 만드는게 편하다.  
그러면 @DirtiesContext 나 수동으로 DI해주지 않아도 된다.  

컨테이너 없는 DI 테스트  
테스트 코드에서 컨테이너가 없이 모든 객체를 직접 생성하고 DI 해줄수도 있다. 설정하는 법은 번거로움이 있지만 코드는 더 단순해지고 이해하기 편해진다.  
어플리케이션 컨텍스트가 없어져서 실행 시간도 줄어든다. DI를 위해 꼭 컨테이너가 필요한 것은 아니다. DI 컨테이너나 프레임워크는 DI를 편하게 적용하도록 도음을 준 뿐,  
컨테이너가 DI를 가능하게 해주는 것은 아니다.   
항상 스프링 컨테이너가 없이 테스트할 수 있는 방법을 가장 우선적으로 고려하자. 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트할 경우  
스프링의 설정을 이용한 DI 방식의 테스트를 이용하면 편리하다.

### 용어
`침투적 기술과 비침투적 기술` : 침투적 기술을 사용하면 어플리케이션 코드가 해당 기술에 종속되는 결과를 가져온다. 반면에 비침투적 기술은 어플리케이션 로직을 담은  
코드에 아무런 영향을 주지 않고 적용이 가능하다. 스프링은 비침투적인 기술의 대표적인 예다.  








