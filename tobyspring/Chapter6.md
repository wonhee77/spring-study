# 6장 AOP

AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반기술의 하나다. 스프링에 적용된 가장 인기 있는 AOP의 적용 대상은 바로 선언적 트랜잭션 기능이다.  
서비스 추상화를 통해 많은 근본적인 문제를 해결했던 트랜잭션 경계설정 기능을 AOP를 이용해 더욱 세련되고 깔끔한 방식으로 바꿔보자. 그리고 그 과정에서 스프링이 AOP를  
도입해야 했던 이유도 알아보자.  

## 6.1 트랜잭션 코드의 분리

### 요약
지금까지 서비스 추상화 기법을 통해 트랜잭션 기술에 독립적으로 만들어줬고, 메일 발송 기술과 환경에도 종속적이지 않게 깔끔한 코드로 다듬어 왔지만 트랜잭션 경계설정을 위해  
넣은 코드들이 찜찜하다. 스프링이 제공하는 깔끔한 트랜잭션 인터페이스를 썼음에도 비즈니스 로직이 주인이어야 할 메소드 안에 이름도 길고 무시무시하게 생긴 트랜잭션 코드가  
더 많은 자리를 차지하고 있다.

기존의 코드를 살펴보면 비즈니스 로직 코드를 사이에 두고 트랜잭션 시작과 종료를 담당하는 코드가 앞뒤에 위치하고 있다.  
그리고 트랜잭션 경계설정의 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없다.  

레벨을 업그레이드하는 비즈니스 로직을 upgradeLevelsInternal() 메소드로 분리하자.  

기존에는 UserServiceTest가 UserService 구체적인 구현 클래스를 직접 참조하고 있기 때문에 결합도가 강하다. UserService를 인터페이스로 만들고 기존 코드는  
UserService 인터페이스 구현 클래스를 만들어넣도록 한다.  

한 번에 두 개의 UserServuce 인터페이스 구현클래스를 동시에 이용한다면 어떻까? 지금 해결하려고 하는 문제는 UserService에는 순수하게 비즈니스 로직을 담고 있는 코드만  
놔두고 트랜잭션 경계설정을 담당하는 코드를 외부로 빼내려는 것이다.  

UserServiceTx라는 UserService를 구현한 또 다른 구현 클래스를 만든다. 이 클래스는 단지 트랜잭션의 경계설정이라는 책임을 맡고 있다. 그리고 스스로는 비즈니스 로직을  
담고 있지 않기 때문에 또 다른 비즈니스 로직을 담고 있는 UserService의 구현 클래스에 실제적인 로직 처리 작업을 위임하는 것이다.  

UserService의 add(), upgradeLevel() 메소드는 인터페이스의 추상메소드로 남겨두고 기존의 UserService를 UserServiceImpl로 변경한다.  
트랜잭션 관련 코드는 모두 제거한다.  

이제 비즈니스 트랜잭션 처리를 담은 UserServiceTx를 만들어보자. UserServiceTx는 기본적으로 UserSerivce를 구현하게 만든다. 그리고 같은 인터페이스를 구현한 다른  
오브젝트에게 고스란히 작업을 위임하게 만들면 된다. UserServiceTx는 사용자 관리라는 비즈니스 로직을 전혀 갖지 않고 고스란히 다른 UserService 구현 오브젝트에 기능을 위임한다.  
이를 위해 UserService 오브젝트를 DI 받을 수 있도록 만든다.

이렇게 준비된 UserServiceTx에 트랜잭션의 경계설정이라는 부가적인 작업을 부여해보자. 구체적인 기술을 알지 못하지만 transactionManager라는 이름의 빈으로 등록된  
트랜잭션 매니저를 DI로 받아뒀다가 트랜잭션 안에서 동작하도록 만들어줘야 하는 메소드 호출의 전과 후에 필요한 트랜잭션 경계설정 API를 사용해주면 된다.  

이제 남은 건 설정파일을 수정해주는 부분이다. 기존에 UserService 빈이 의존하고 있던 transactionManager는 UserServiceTx의 빈이, userDao와 MailSender는  
UserServiceImpl 빈이 각각 의존하도록 프로퍼티 정보를 분리한다.  

#### 트랜잭션 분리에 따른 테스트 수정
기존의 @Autowired 어노테이션으로 주입하던 UserService는 interface로 변경되었기 때문에 수정할 것이 없다. 하지만 UserService 타입의 빈이 2개이기 때문에  
어떤 빈이 주입될지 알지 못한다. @Autowired는 기본적으로 타입을 이용해 빈을 찾지만 만약 타입으로 하나의 빈을 결정할 수 없는 경우에는 필드 이름을 이용해 빈을 찾는다.

@Autowired UserService userService; // 타입이 UserService이고 id가 userService인 빈을 찾아서 주입

다음으로 UserServiceImpl 빈을 주입해야한다. 단순히 UserService의 기능을 테스트할 때는 인터페이스로 구체적인 클래스 정보를 노출할 필요가 없지만  
이렇게 목 오브젝트를 이용해 수동 DI를 적용하는 테스트라면 어떤 클래스의 오브젝트인지 분명하게 알 필요가 있다.

@Autowired UserServiceImpl userServiceImpl;

#### 트랜잭션 경계설정 코드 분리의 장점
트랜잰션 경계설정 코드의 분리와 DI를 통한 연결의 장점  
첫째, 이제 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다.  
트랜잭션은 DI를 이용해 UserServiceTx와 같은 트랜잭션 기능을 가진 오브젝트가 먼저 실행되도록 만들기만 하면 된다.  
두번째 장점은 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다는 것이다.  


## 6.2 고립된 단위 테스트 

### 요약 
가장 편하고 좋은 테스트 방법은 가능한 작은 단위로 쪼개서 테스트하는 것이다. 작은 단위의 테스트가 좋은 이유는 테스트가 실패했을 때 그 원일을 찾기 쉽기 때문이다.  
또한 테스트 단위가 작아야 테스트의 의도나 내용이 분명해지고, 만들기도 쉬워진다. 테스트 대상의 단위가 커지면 충분한 테스트를 만들기도 쉽지 않다.  

UserService에서 테스트 단위를 쪼개지 않았다면 그 뒤의 의존관계를 따라 등장하는 오브젝트와 서비스, 환경 등이 모두 합쳐져 테스트 대상이 되는 것이다.  

그래서 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다. 테스트를 의존 대상으로부터 분리해서 고립시키는 방법은  
MailSender에 적용해봤던 대로 테스트를 위한 대역을 사용하는 것이다. MailSender에는 이미 DummyMailSender라는 테스트 스텁을 적용했다. 또 테스트 대역이 테스트 검증에도  
참여할 수 있도록, 특별히 만든 MockMailSender라는 목 오브젝트로 사용해봤다.  

UserDao는 단지 테스트 대상의 코드가 정상적으로 수행되도록 도와주기만 하는 스텁이 아니라, 부가적인 검증 기능까지 가진 목 오브젝트로 만들었다. 그 이유는 고립된 환경에서  
동작하는 upgradeLevels()의 테스트 결과를 검증할 방법이 필요하기 때문이다. 이 메소드는 리턴 타입이 void이기 때문에 테스트가 제대로 동작하는지 검증하는 방법은 DB의  
값을 확인한느 방법 뿐이다. 그러나 고립테스트에서는 DB를 사용할 수 없다. 그래서 Mock객체를 만들어 넘겨받은 인자를 통해 테스트의 동작을 확인하였다.  

이 책에서는 앞으로 upgradeLevels() 테스트처럼 '테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜  
테스트하는 것'을 단위테스트라고 부르겠다. 반면에 두 개 이상의, 성격이나 계층의 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의  
리소스가 참여하는 테스트는 통합 테스트라고 부르겠다.

단위 테스트와 통합 테스트 중 어떤 방법을 쓸지 결정할 가이드라인  
- 항상 단위 테스트를 먼저 고려한다. 
- 하나의 클래스나 성격과 목적이 같은 긴밀한 클래스 몇 개를 모아서 외부와의 의존관계를 모두 차단하고 필요에 따라 스텁이나 목 오브젝트 등의 테스트 대역을 이용하도록 테스트를 만든다. 
- 외부 리소스를 사용해야만 가능한 테스트는 통합테스트로 만든다.
- DAO는 그 자체로 로직을 담고 있기 보다는 DB를 통해 로직을 수행하는 인터페이스와 같은 역할을 한다. 따라서 DAO는 DB까지 연동하는 테스트로 만드는 편이 효과적이다. 
- 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다. 다만, 단위 테스트를 충분히 거쳤다면 통합 테스트의 부담은 상대적으로 줄어든다.
- 단위 테스트를 만들기가 너무 복잡하다고 판단되는 코드는 처음부터 통합 테스트를 고려해본다.
- 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트다. 스프링의 설정 자체도 테스트 대상이고, 스프링을 이용해 좀 더 추상적인 레벨에서 테스트가 필요할 경우  
스프링 테스트 컨텍스트 프레임워크를 이용해 통합 테스트를 작성한다.  
  
코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습괸이다. 테스트하기 편하게 만들어진 코드는 깔끔하고 좋은 코드가 될 가능성이 높다.  

단위 테스트를 만들기 위해서는 스텁이나 목 오브젝트의 사용이 필수적이다. 목 오브젝트는 사용하지 않는 인터페이스도 모두 일일이 구현해야되기 때문에 번거롭다.  
다행히도, 이런 번거로운 목 오브젝트를 편리하게 작성하도록 도와주는 다양한 목 오브젝트 지원 프레임워크가 있다.  

#### Mockito 프레임워크
Mockito와 같은 목 프레임워크의 특징은 목 클래스를 일일이 준비해둘 필요가 없다. org.mockito.Matchers 클래스의 mock() 메소드를 스태틱 임포트를 사용해  
로컬 메소드처럼 호출하면 편리하다.

```java
UserDao mockUserDao = mock(UserDao.class);
```

getAll() 메소드가 불려올 때 사용자 목록을 리턴하도록 스텁기능을 추가해줘야 한다.

```java
when(mockUserDao.getAll()).thenReturn(this.users);
```

Mockito 목 오브젝트는 다음의 네 단계를 거쳐서 사용하면 된다.  
- 인터페이스를 이용해 목 오브젝트를 만든다.
- 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다. 메소드가 호출되면 예외를 강제로 던지게 만들 수 있다. 
- 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 만든다. 
- 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇번 호출됐는질를 검증한다. 







